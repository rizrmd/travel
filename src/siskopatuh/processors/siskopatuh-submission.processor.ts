/**
 * Integration 6: SISKOPATUH Submission Processor
 * BullMQ job processor for automated SISKOPATUH submissions
 */

import { Processor, WorkerHost } from "@nestjs/bullmq";
import { Job } from "bullmq";
import { Logger } from "@nestjs/common";
import { SiskopatuhService } from "../services/siskopatuh.service";

@Processor("siskopatuh-submission")
export class SiskopatuhSubmissionProcessor extends WorkerHost {
  private readonly logger = new Logger(SiskopatuhSubmissionProcessor.name);

  constructor(private readonly siskopatuhService: SiskopatuhService) {
    super();
  }

  async process(job: Job): Promise<any> {
    switch (job.name) {
      case "submit-jamaah-registration":
        return this.submitJamaahRegistration(job);
      case "submit-departure-manifest":
        return this.submitDepartureManifest(job);
      case "submit-return-manifest":
        return this.submitReturnManifest(job);
      case "retry-failed-submission":
        return this.retryFailedSubmission(job);
      case "auto-generate-departure-manifest":
        return this.autoGenerateDepartureManifest(job);
      case "auto-generate-return-manifest":
        return this.autoGenerateReturnManifest(job);
      default:
        this.logger.warn(`Unknown job name: ${job.name}`);
    }
  }

  /**
   * Process jamaah registration submission
   */
  async submitJamaahRegistration(job: Job) {
    const { submissionId, tenantId } = job.data;

    this.logger.log(
      `Processing jamaah registration submission: ${submissionId}`,
    );

    try {
      await this.siskopatuhService.processSubmission(submissionId);

      this.logger.log(
        `Jamaah registration submission completed: ${submissionId}`,
      );

      return {
        success: true,
        submissionId,
      };
    } catch (error) {
      this.logger.error(
        `Failed to process jamaah registration: ${error.message}`,
        error.stack,
      );
      throw error;
    }
  }

  /**
   * Process departure manifest submission
   */
  async submitDepartureManifest(job: Job) {
    const { submissionId, tenantId } = job.data;

    this.logger.log(
      `Processing departure manifest submission: ${submissionId}`,
    );

    try {
      await this.siskopatuhService.processSubmission(submissionId);

      this.logger.log(
        `Departure manifest submission completed: ${submissionId}`,
      );

      return {
        success: true,
        submissionId,
      };
    } catch (error) {
      this.logger.error(
        `Failed to process departure manifest: ${error.message}`,
        error.stack,
      );
      throw error;
    }
  }

  /**
   * Process return manifest submission
   */
  async submitReturnManifest(job: Job) {
    const { submissionId, tenantId } = job.data;

    this.logger.log(`Processing return manifest submission: ${submissionId}`);

    try {
      await this.siskopatuhService.processSubmission(submissionId);

      this.logger.log(`Return manifest submission completed: ${submissionId}`);

      return {
        success: true,
        submissionId,
      };
    } catch (error) {
      this.logger.error(
        `Failed to process return manifest: ${error.message}`,
        error.stack,
      );
      throw error;
    }
  }

  /**
   * Retry failed submission
   */
  async retryFailedSubmission(job: Job) {
    const { submissionId } = job.data;

    this.logger.log(`Retrying failed submission: ${submissionId}`);

    try {
      await this.siskopatuhService.processSubmission(submissionId);

      this.logger.log(`Retry successful for submission: ${submissionId}`);

      return {
        success: true,
        submissionId,
      };
    } catch (error) {
      this.logger.error(
        `Retry failed for submission ${submissionId}: ${error.message}`,
        error.stack,
      );
      throw error;
    }
  }

  /**
   * Auto-generate departure manifest 3 days before departure
   * This job would be scheduled by a cron job or triggered by package status change
   */
  async autoGenerateDepartureManifest(job: Job) {
    const { packageId, tenantId } = job.data;

    this.logger.log(
      `Auto-generating departure manifest for package: ${packageId}`,
    );

    try {
      await this.siskopatuhService.submitDepartureManifest(packageId, tenantId);

      this.logger.log(
        `Auto-generated departure manifest for package: ${packageId}`,
      );

      return {
        success: true,
        packageId,
      };
    } catch (error) {
      this.logger.error(
        `Failed to auto-generate departure manifest: ${error.message}`,
        error.stack,
      );
      throw error;
    }
  }

  /**
   * Auto-generate return manifest on return date
   * This job would be scheduled by a cron job or triggered by package return
   */
  async autoGenerateReturnManifest(job: Job) {
    const { packageId, tenantId } = job.data;

    this.logger.log(
      `Auto-generating return manifest for package: ${packageId}`,
    );

    try {
      await this.siskopatuhService.submitReturnManifest(packageId, tenantId);

      this.logger.log(
        `Auto-generated return manifest for package: ${packageId}`,
      );

      return {
        success: true,
        packageId,
      };
    } catch (error) {
      this.logger.error(
        `Failed to auto-generate return manifest: ${error.message}`,
        error.stack,
      );
      throw error;
    }
  }
}
